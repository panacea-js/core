const { i18n } = Panacea.container

interface nest {
  [parent: string] : nest | {}
}

/**
 * Creates a nested object where the nesting keys follow the paths
 * analogous to the dotted syntax provided in the hook.
 *
 * For example, if hook is 'top.second.third' then resulting nest will
 * appear as: { top: { second: { third: {} } } }
 * Note that the deepest items are empty objects.
 *
 * @param hook String
 *   The hook to transform to a nested object.
 *
 * @param nest Object
 *   It's suggested to pass an empty object initialised from the calling
 *   function. nest will be altered through running this function.
 *
 * @returns Object
 */
const compileNestFromDotSeparated = function (hook: string, nest: nest = {}) {
  if (hook.indexOf('.') !== -1) {
    let hookParts = hook.split('.')
    let shifted = hookParts.shift()

    if (!shifted) {
      return nest
    }

    if (!nest.hasOwnProperty(shifted)) {
      nest[shifted] = {}
    }

    nest[shifted] = compileNestFromDotSeparated(hookParts.join('.'), nest[shifted])
  } else {
    nest[hook] = {}
  }

  return nest
}

/**
 * Pretty-prints an indented list based on a nest generated by compileNestFromDotSeparated()
 *
 * @see compileNestFromDotSeparated()
 *
 * @param nest
 *   The nested object of keys to be used in the indented list.
 *
 * @param indentSize
 *   The number of spaces used for each indent.
 *
 * @param _level
 *   (Internal) for tracking current indent.
 *
 * @returns String
 */
const formatNestedObjectKeys = function (nest: nest, indentSize = 2, _level = 0) {
  const { _ } = Panacea.container

  let output = ''

  _(nest).forEach((item, key) => {
    let indent = ''

    _.times(_level * indentSize, () => {
      indent += ' '
    })

    output += `\n${indent} - ${key}`

    if (!_.isEmpty(item)) {
      let increasedLevel = _level + 1
      output += formatNestedObjectKeys(item, indentSize, increasedLevel)
    }
  })

  return output
}

/**
 * Convert a string like '2Mb' to its bytes equivalent.
 */
const convertFileSizeShortHandToBytes = function (value: string): number | Error {
  // If passed value is a string without any suffixes then treat as an integer.
  if (parseInt(value).toString() === value) {
    return parseInt(value)
  }

  const sizes: any = {
    k: 1,
    m: 2,
    g: 3,
    t: 4,
    kb: 1,
    mb: 2,
    gb: 3,
    tb: 4
  }

  if (typeof value === 'string') {
    for (let size in sizes) {
      if (value.indexOf(size) !== -1 || value.indexOf(size.toUpperCase()) !== -1) {
        return parseInt(value.replace(size, '').replace(size.toUpperCase(), '')) * (Math.pow(1024, sizes[size]))
      }
    }
    return new TypeError(i18n.t('core.formatters.shortHandToBytes.cannotConvert', {value})) // Could not find a way to convert file size shorthand string: {value}
  }

  return parseInt(value)
}

export {
  convertFileSizeShortHandToBytes,
  compileNestFromDotSeparated,
  formatNestedObjectKeys
}
